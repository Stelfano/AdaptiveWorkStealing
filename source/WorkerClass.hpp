/**
 * @file WorkerClass.hpp
 * @author Stefano Romeo
 * @brief Worker node definition 
 * @version 0.1
 * @date 2024-04-03
 *
 */

#include "Node.hpp"
#include <vector>
#include <random>
#include <cstdlib>
#include <thread>
#include <atomic>
#include <cstring>
#include <functional>
#include <shared_mutex>
#include <mutex>
#include <syncstream>
#include <unistd.h>
#include <time.h>

using namespace std;

class Worker : public Node{

    protected:
        vector<int> *buffer;        ///<Pointer to particle buffer instatiated as an object of class std::vector
        int counter;                ///<Counter of workstealing events
        
        /**
         * @brief Function used to reduce or expand vector particles
         *
         * This function recieves a generated number and reduces or expands the buffer containing all other particles, its purpose its to simulate particle generation
         * total particles size is increased o decreased as result of the operation
         * 
         * @param generatedNumber Number generated by a distribution indicating the number of particles generated or destroyed
         */
        void probabilityIncreaseVectorSize(int generatedNumber){

            if(totalParticles < abs(generatedNumber))
                return;
            
            if(generatedNumber > 0){
                for(int i = 0;i < generatedNumber;i++){
                    buffer->push_back(1);
                    totalParticles++;
                }
            }

            if(generatedNumber < 0){
                for(int i = 0;i < abs(generatedNumber);i++){
                    buffer->pop_back();
                    totalParticles--;
                }
            }
        }

        void moveParticle(int workLoad) volatile {
            volatile int val = 0;

            for(int i = 0;i<workLoad;i++){
                val++;
            }
        }

        /**
         * @brief Function that injects data in a worker node 
         * Injected particles from a matchmaker into a worker are integrated in the vector buffer here, UNLOCKED status is then sent upwards to signal termination
         * of the injection, total particles and counter are also updated
         * 
         * @param stealingQuantity Quantity of particles to be injected
         */
        void injectDataInNode(int stealingQuantity){
            counter++;
            MPI_Win_lock(MPI_LOCK_EXCLUSIVE, nodeRank, 0, inWindow);
            cout << "WORKER : " << nodeRank << "DECLARES : " << totalParticles << " BEFORE STEALING" << endl;
            buffer->insert(buffer->end(), inWindowBuffer, inWindowBuffer + stealingQuantity);
            MPI_Win_unlock(nodeRank, inWindow);
            totalParticles += stealingQuantity;
            memset(inWindowBuffer, 0, MAX_STEAL);
            cout << "WORKER : " << nodeRank << " HAS RECIEVED : " << stealingQuantity << " PARTICLES" << endl;
            cout << "WORKER : " << nodeRank << " HAS INTEGRATED : " << totalParticles << " PARTICLES " << counter << endl;

            declareStatus(UNLOCKED);
        }

        /**
         * @brief Function that deletes data in a worker node
         * This function negotiates particles to be stolen with a matchmaker, after available particle number is sent reduction is stopped via mutex
         * and particles are stolen by the matchmaker, those particles are the erased from particles buffer and UNLOCKED status is declared, local reduction is free
         * to resume
         *
         * @param stealingQuantity Quantity of particles to be stolen (this is not necessarily the actual number of particles available)
         */
        void deleteDataFromNode(int stealingQuantity){
            int actualSteal = 0;
            if(totalParticles > stealingQuantity)
                actualSteal = stealingQuantity;
            else
                actualSteal = totalParticles;

            MPI_Win_lock(MPI_LOCK_EXCLUSIVE, nodeRank, 0, outWindow);
            memset(outWindowBuffer, 0, MAX_STEAL);
            copy(buffer->begin(), buffer->begin()+actualSteal, outWindowBuffer);
            MPI_Win_unlock(nodeRank, outWindow);

            MPI_Send(&actualSteal, 1, MPI_INT, parentRank, COMM, MPI_COMM_WORLD);
            cout << "TOTAL PARTICLES AT DELETION TIME : " << buffer->size() << " IN NODE : " << nodeRank << endl;
            buffer->erase(buffer->begin(), buffer->begin() + actualSteal);
            totalParticles -= actualSteal;
            cout << "DELETED " << actualSteal << " PARTICLES FROM " << nodeRank << endl;
            cout << "BUFFER SIZE : " << buffer->size() << endl;
            declareStatus(UNLOCKED);
        }

    public:

        /**
         * @brief Construct a new Worker object
         * Buffer vector is created and total particles is initialized with chunk size
         * 
         * @param parentRank 
         * @param recvBuffer 
         * @param chunkSize 
         * @param localAverage 
         * @param threshold 
         */
        Worker(int parentRank, int *recvBuffer, int chunkSize, float localAverage, int thresholdValue) : 
        Node(parentRank, chunkSize, recvBuffer, chunkSize, localAverage, thresholdValue) {
               this->buffer = new vector<int>();

               totalParticles = chunkSize;
               counter = 0;
        }

        /**
         * @brief Destroy the Worker object
         * In this function only particle buffer is destroyed
         */
        virtual ~Worker(){
            delete buffer;
        }


        /**
         * @brief Local reduction function to simulate particles
         * 
         * This function simulates particle activity by sum of integers, for every integer added to the total value a random number in an interval is taken from a
         * uniform distribution to simulate new particle generation, to proc work stealing only some nodes may generate new particles, particles are constantly copied
         * inside outWindowBuffer to allow a matchmaker to recover those particles, when termination flag is active (all workers have to be idle for this to happen)
         * reduction ends and statusThread and recieverThread are joined
         *
         * @return Total particles destroyed
         */
        int localReduction(){

            random_device randomDev;
            thread statusThread;
            thread recieverThread;
            default_random_engine randomEng(randomDev());
            randomEng.seed(42);
            uniform_int_distribution<int> uniform_dist(0, 0);
            bool idleFlag = false;

            cout << "INITIAL SAMPLE --> " << recvBuffer[0] << endl;
            
            for(int i = 0;i<chunkSize;i++){
                buffer->push_back(recvBuffer[i]);
            }

            cout << "BUFFER SAMPLE --> " << buffer->size() << endl;


            //Qui si lanciano i thread
            statusThread = thread(&Worker::sendStatusFunction, this);
            recieverThread = thread(&Worker::recieveMessageFromMatchmaker, this);

            int accumulatedResult = 0;
            int totalGenerated = 0;
            bool tempFlag = true;
            
            unique_lock<shared_mutex> totalParticlesLock(totalParticleMutex, defer_lock);

            while(!done){

                if(totalParticles > 0){
                    totalParticlesLock.lock();
                    accumulatedResult++;
                    int val = uniform_dist(randomEng);
                    totalGenerated+=val;
                    buffer->pop_back();
                    totalParticles--;
                    tempFlag = true;

                    moveParticle(50000);

                    if(nodeRank == 6 && totalGenerated < 60000){
                            totalParticles++;
                            buffer->push_back(1);
                            totalGenerated++;
                        }
                    totalParticlesLock.unlock();
                }else{
                    if(tempFlag == true){
                        calculate_time();
                        cout << "RANK : " << nodeRank << " HAS GONE IDLE WITH : " << accumulatedResult  << endl;
                        tempFlag = false;
                    }
                }
            }

            calculate_time();
            cout << "LOCAL REDUCTION HAS ENDED IN RANK : " << nodeRank << endl;
            cout << "GENERATED PARTICLES : " << totalGenerated << " IN RANK : " << nodeRank << endl;
            statusThread.join();
            recieverThread.join();
                
            return accumulatedResult;
        }
};